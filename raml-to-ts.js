const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const ejs = require('ejs');
const camelCase = require('camelcase');
const pascalCase = require('pascal-case');
const prettier = require('prettier');
const { json2ts } = require('json-ts');

const LANG = 'ja';
const CHATWORK_URL = 'https://api.chatwork.com/v2';

const NAME_MAPPER = {
  getRoomsMembers: 'getRoomMembers',
  putRoomsMembers: 'putRoomMembers',
  putRoomsMessagesRead: 'putRoomMessagesRead',
  putRoomsMessagesUnread: 'putRoomMessagesUnread',
  getRoomsMessagesInfo: 'getRoomMessage',
  putRoomsMessagesInfo: 'putRoomMessage',
  deleteRoomsMessagesInfo: 'deleteRoomMessage',
  getRoomsMessages: 'getRoomMessages',
  postRoomsMessages: 'postRoomMessage',
  putRoomsTasksStatus: 'putRoomTaskStatus',
  getRoomsTasksInfo: 'getRoomTask',
  getRoomsTasks: 'getRoomTasks',
  postRoomsTasks: 'postRoomTask',
  getRoomsFilesInfo: 'getRoomFile',
  getRoomsFiles: 'getRoomFiles',
  postRoomsFiles: 'postRoomFile',
  getRoomsLink: 'getRoomLink',
  postRoomsLink: 'postRoomLink',
  putRoomsLink: 'putRoomLink',
  deleteRoomsLink: 'deleteRoomLink',
  getRoomsInfo: 'getRoom',
  putRoomsInfo: 'putRoom',
  deleteRoomsInfo: 'deleteRoom',
  postRooms: 'postRoom',
  putIncomingRequestsInfo: 'putIncomingRequest',
  deleteIncomingRequestsInfo: 'deleteIncomingRequest',
};

(function main() {
  const ramlStr = fs.readFileSync(
    path.join(__dirname, 'api', 'RAML', `api-${LANG}.raml`),
    { encoding: 'utf8' },
  );

  const ramlData = yaml.safeLoad(prettier.format(ramlStr, { parser: 'yaml' }));

  ramlData.traits = parseTraits(ramlData);

  const data = parseApi(ramlData);
  mapTraits(ramlData.traits, data);
  parseResponseSchema(data);
  convertSchemaToInterfaces(data);
  // console.log(data);

  const responseInterfaces = renderResponsesInterfaces(data);

  const paramInterfaces = renderParamInterfaces(data);

  const apiClass = renderApiClass(data, ramlData);

  const importData = `
// This file is automatically generated by "raml-to-ts.js".

import axios from 'axios';
`;

  const tsData =
    importData +
    apiClass +
    addExport(paramInterfaces) +
    addExport(responseInterfaces);

  const prettifiedTsData = prettier.format(tsData, {
    ...require(path.join(__dirname, '.prettierrc.json')),
    parser: 'typescript',
  });

  // console.log(prettifiedTsData);

  fs.writeFileSync(path.join(__dirname, 'src', 'api.ts'), prettifiedTsData);
})();

function parseTraits(ramlData) {
  const { traits } = ramlData;
  return traits.reduce((pre, cur) => Object.assign(pre, cur), {});
}

function mapTraits(traits, data) {
  data
    .filter(data => !data.example && Array.isArray(data.is))
    .forEach(data => {
      data.is.forEach(is => {
        if (traits[is]['responses']['200']) {
          const example = getExample(traits[is]['responses']);
          if (example) data.example = example.replace(/^\|/, '');
          const schema = getSchema(traits[is]['responses']);
          if (schema) data.schema = schema.replace(/^\|/, '');
        }
      });
    });
}

function parseApi(ramlData, prefix = '') {
  return Object.keys(ramlData)
    .filter(key => key.match(/^\//))
    .map(uri => {
      const api = ramlData[uri];
      return [
        ...parseApi(api, prefix + uri),
        ...parseEndpoint(api, prefix + uri),
      ];
    })
    .reduce((pre, cur) => [...pre, ...cur], []);
}

function parseEndpoint(api, uri) {
  return Object.keys(api)
    .filter(method => method.match(/GET|POST|PUT|DELETE/))
    .map(method => parseMethod(method, api[method], uri));
}

function parseMethod(method, api, uri) {
  const { description, queryParameters, responses, is } = api;
  const funcName = getFuncName(method, uri);
  const ifName = pascalCase(funcName);
  const funcParams = getFuncParams(uri);
  const funcParamsWithTypes = funcParams.map(
    param => param + ': number|string',
  );
  const funcParam = funcName + 'Param';
  const funcParamWithTypes = funcParam + ': ' + ifName + 'Param';
  const params = getQueryParameters(queryParameters);

  const example = getExample(responses);
  const schema = getSchema(responses);

  return {
    method,
    ifName,
    funcName,
    funcParams,
    funcParamsWithTypes,
    funcParam,
    funcParamWithTypes,
    api,
    uri,
    params,
    example,
    schema,
    is,
    description: description
      ? description.replace(/^\|\s+/, '').replace(/\n/g, '')
      : '',
  };
}

function getFuncName(method, uri) {
  let uris = uri.split('/').filter(uri => uri);
  const isQueryLast = uris[uris.length - 1].match(/^{.*}$/);
  if (isQueryLast) uris.push('info');
  uris = uris.filter(uri => !uri.match(/^{.*}$/));

  const funcName = camelCase([method, uris.join('_')].join('_'));

  return NAME_MAPPER[funcName] || funcName;
}

function getQueryParameters(queryParameters = {}) {
  const params = Object.keys(queryParameters).map(name => ({
    ...queryParameters[name],
    name,
  }));

  params.forEach(param => {
    if (param.type === 'integer') param.type = 'number';
    if (param.type === 'boolean') param.type = '0|1';
    if (param.enum) param.type = `'${param.enum.join(`'|'`)}'`;
    if (param.displayName) {
      param.displayName = param.displayName.replace(/\n/g, '');
    }
    if (!param.required) param.name += '?';
  });

  return params;
}

function getFuncParams(uri) {
  const funcParams = [];
  if (uri.includes('{room_id}')) funcParams.push('room_id');
  if (uri.includes('{message_id}')) funcParams.push('message_id');
  if (uri.includes('{task_id}')) funcParams.push('task_id');
  if (uri.includes('{file_id}')) funcParams.push('file_id');
  if (uri.includes('{request_id}')) funcParams.push('request_id');
  return funcParams;
}

function getExample(responses = {}) {
  if (!responses['200']) return;
  const example = responses['200']['body']['application/json']['example'];
  return example ? example.replace(/^\|/, '') : undefined;
}

function getSchema(responses = {}) {
  if (!responses['200']) return;
  const schema = responses['200']['body']['application/json']['schema'];
  return schema ? schema.replace(/^\|/, '') : undefined;
}

function parseResponseSchema(data) {
  data
    .filter(d => d.schema)
    .forEach(d => {
      if (d.schema) d.schema = parseSchema(d.schema);
    });
}

function parseSchema(schema) {
  const parse = schema => {
    if (schema.type === 'array') {
      return schema.items.map(item => parse(item));
    } else {
      Object.entries(schema.properties).forEach(([name, prop]) => {
        prop.name = name;
        if (prop.type === 'object')
          schema.properties[name]['properties'] = parse(prop);
        if (prop.type === 'integer') prop.type = 'number';
        if (prop.type === 'boolean') prop.type = '0|1';
        if (prop.enum) prop.type = `'${prop.enum.join(`'|'`)}'`;
      });
    }
    return schema.properties;
  };
  return parse(JSON.parse(schema));
}

function convertSchemaToInterfaces(data) {
  data
    .filter(d => d.schema)
    .forEach(d => {
      convertSchemaToInterface(d);
    });
}

function convertSchemaToInterface(d) {
  if (d.ifName === 'GetMyTasks') {
    console.log();
  }
  const interfaces = [];
  const types = [];
  const convert = ({ schema, ifName, addName = '', isItem = false }) => {
    if (Array.isArray(schema)) {
      convert({ schema: schema[0], ifName, addName, isItem: true });
      types.push({
        name: pascalCase([ifName, addName, 'Response'].join('_')),
        itemName: pascalCase([ifName, addName, 'Response', 'Item']),
      });
    } else {
      const properties = Object.values(schema);
      properties.forEach(prop => {
        if (prop.type === 'object') {
          // addName = pascalCase([addName, prop.name].join('_'));
          const objAddName = addName + pascalCase(prop.name);
          convert({
            schema: prop.properties,
            ifName,
            addName: objAddName,
          });
          prop.type = pascalCase([ifName, objAddName, 'Response'].join('_'));
        } else if (prop.type === 'array') {
          let type = prop.items[0].type;
          if (type === 'integer') type = 'number';
          prop.type = type + '[]';
        }
      });
      interfaces.push({
        name: pascalCase(
          [ifName, addName, 'Response', isItem ? 'Item' : ''].join('_'),
        ),
        properties,
      });
    }
  };
  const { schema, ifName } = d;
  convert({ schema, ifName });
  d.interfaces = interfaces;
  d.types = types;
}

function renderParamInterfaces(data) {
  return ejs.render(
    fs.readFileSync(
      path.join(__dirname, '__templates', '__paramInterface.ejs'),
      {
        encoding: 'utf8',
      },
    ),
    { data: data.filter(d => d.params) },
  );
}

function renderResponsesInterfaces(data) {
  const schemaData = [];
  const exampleData = [];

  data.forEach(d => {
    if (d.types || d.interfaces) {
      schemaData.push(d);
    } else if (d.example) {
      if (d.example) exampleData.push(d);
    }
  });

  const interfacesFromSchema = ejs.render(
    fs.readFileSync(
      path.join(__dirname, '__templates', '__responseInterface.ejs'),
      { encoding: 'utf8' },
    ),
    { data: schemaData },
  );

  const interfacesFromExample = exampleData
    .map(d =>
      json2ts(d.example, {
        rootName: d.ifName + 'Response',
        prefix: '',
      }),
    )
    .join('\n');

  return interfacesFromSchema + interfacesFromExample;
}

function renderApiClass(data, ramlData) {
  return ejs.render(
    fs.readFileSync(path.join(__dirname, '__templates', '__class.ejs'), {
      encoding: 'utf8',
    }),
    { data, ramlData, CHATWORK_URL },
  );
}

function addExport(tsData) {
  return tsData.replace(/interface/g, 'export interface');
}
